{
  "tasks": [
    {
      "id": 1,
      "title": "Project Setup and Configuration",
      "description": "Initialize the project with Next.js, TypeScript, and essential dependencies.",
      "details": "Use create-next-app to set up a new Next.js project with TypeScript. Install additional dependencies: styled-components, @types/styled-components, i18next, react-i18next, next-i18next. Configure ESLint and Prettier for code quality. Set up a basic folder structure for components, pages, styles, and utilities.",
      "testStrategy": "Verify correct installation of all dependencies. Run linting and type-checking to ensure proper configuration.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Core Layout Components",
      "description": "Create reusable layout components including Header and Footer.",
      "details": "Develop a Header component with logo, navigation links, and placeholders for language selection and dark mode toggle. Create a Footer component with necessary links and information. Use styled-components for styling. Implement responsive design using CSS Grid and Flexbox.",
      "testStrategy": "Create unit tests for Header and Footer components using React Testing Library. Ensure responsiveness across different screen sizes.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Design System and Theme Setup",
      "description": "Establish a design system with brand colors, typography, and reusable UI components.",
      "details": "Define a theme object with brand colors, typography scales, and spacing units. Create a global style reset. Implement a ThemeProvider using styled-components. Develop reusable UI components such as buttons, input fields, and cards. Use a warm color palette and sans-serif typography as specified in the PRD.",
      "testStrategy": "Create a storybook to showcase and test individual components. Ensure consistent theming across all components.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Home Page",
      "description": "Develop the main landing page with app introduction, visual content, and download buttons.",
      "details": "Create a Next.js page for the home route. Implement sections for app introduction, feature highlights, and visual content (images of dogs walking, app screenshots). Add 'Start' buttons linking to Google Play Store and App Store. Use Next/Image for optimized image loading. Implement lazy loading for images below the fold.",
      "testStrategy": "Write integration tests for the Home page. Perform lighthouse audits for performance, accessibility, and SEO. Test responsiveness and image loading across devices.",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Basic Sign Up Page",
      "description": "Create a page for email-based user registration.",
      "details": "Develop a sign-up form with fields for email and password. Implement client-side validation for email format and password strength. Use Zod for form validation. Create a custom hook for form handling. Style the form using the established design system.",
      "testStrategy": "Write unit tests for form validation logic. Create integration tests for the sign-up flow. Test form submission with valid and invalid data.",
      "priority": "high",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Email Verification System",
      "description": "Add email verification functionality to the sign-up process.",
      "status": "done",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Email verification system has been fully implemented with the following components:\n\n1. Email Service Abstraction:\n   - Nodemailer implementation with Gmail integration\n   - Interface designed for easy replacement with SendGrid\n   - HTML email templates with DoGether branding\n\n2. JWT-based Security:\n   - 24-hour token validity\n   - Purpose-specific token validation ('email_verification')\n   - Strong secret key implementation\n\n3. Complete UI/UX:\n   - Responsive email verification page (/verify-email)\n   - Status-specific UI (loading/success/failure/expired)\n   - Automatic redirect and resend functionality\n   - Full support for 3 languages (Korean/English/Japanese)\n\n4. System Integration:\n   - Email verification connected to registration page\n   - User-friendly messages and feedback\n\nTechnical Structure:\n- API endpoints: /api/auth/send-verification, /api/auth/verify-email\n- Libraries: src/lib/auth.ts (JWT), src/lib/email.ts (email service)\n- Environment variables: EMAIL_USER, EMAIL_PASSWORD, JWT_SECRET\n- Documentation: EMAIL_VERIFICATION_SETUP.md (complete setup guide)",
      "testStrategy": "System is ready for testing with the following approach:\n1. Configure environment variables for testing\n2. Test the complete verification flow including:\n   - Email sending functionality\n   - Token validation and expiration\n   - UI states across all supported languages\n   - Integration with registration process\n3. Verify error handling for invalid/expired tokens\n4. Test email template rendering across different email clients",
      "subtasks": [
        {
          "id": "6.1",
          "title": "Email Service Abstraction",
          "description": "Implemented Nodemailer with Gmail integration and created an interface for easy replacement with SendGrid. Developed HTML email templates with DoGether branding.",
          "status": "completed"
        },
        {
          "id": "6.2",
          "title": "JWT-based Security Implementation",
          "description": "Implemented JWT tokens with 24-hour validity, purpose-specific validation for 'email_verification', and strong secret key usage.",
          "status": "completed"
        },
        {
          "id": "6.3",
          "title": "UI/UX Development",
          "description": "Created responsive verification page with status-specific UI states, automatic redirect, resend functionality, and support for Korean, English, and Japanese languages.",
          "status": "completed"
        },
        {
          "id": "6.4",
          "title": "System Integration",
          "description": "Connected email verification to registration process with user-friendly messaging and feedback. Implemented API endpoints and necessary libraries.",
          "status": "completed"
        },
        {
          "id": "6.5",
          "title": "Documentation",
          "description": "Created EMAIL_VERIFICATION_SETUP.md with complete setup guide including environment variable configuration.",
          "status": "completed"
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement Dark Mode",
      "description": "Add a dark mode toggle with a dog paw design.",
      "details": "Create a dark mode theme variant. Implement a toggle component with a dog paw design. Use React Context for theme state management. Persist theme preference in localStorage. Ensure smooth transition between light and dark modes.",
      "testStrategy": "Write unit tests for the theme toggle component. Test theme persistence across page reloads. Verify correct application of dark mode styles across all components.",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Internationalization",
      "description": "Add support for multiple languages (Korean, English, Japanese).",
      "details": "Set up next-i18next for internationalization. Create translation files for Korean, English, and Japanese. Implement a language selector in the header. Ensure all static text is internationalized. Use ICU message format for complex translations.",
      "testStrategy": "Write tests to verify correct loading of translations. Test language switching functionality. Ensure no hard-coded strings are present in the components.",
      "priority": "medium",
      "dependencies": [
        2,
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Social Login Options",
      "description": "Add Google, Kakao, and Naver social login options.",
      "details": "Integrate OAuth libraries for Google, Kakao, and Naver. Create API routes for handling OAuth callbacks. Implement social login buttons on the sign-up page. Handle user creation/login based on social profile information. Use NextAuth.js for session management.",
      "testStrategy": "Mock OAuth providers in tests. Write integration tests for each social login flow. Test handling of various OAuth response scenarios.",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Optimize Performance and SEO",
      "description": "Implement performance optimizations and SEO best practices.",
      "details": "Implement code splitting and lazy loading using Next.js dynamic imports. Optimize images using Next/Image and implement responsive images. Add metadata and Open Graph tags for better SEO. Implement a sitemap.xml and robots.txt. Use next/script for optimal loading of third-party scripts.",
      "testStrategy": "Run Lighthouse audits and ensure scores above 90 for Performance, Accessibility, and SEO. Test load times across various network conditions. Verify correct rendering of meta tags for SEO.",
      "priority": "medium",
      "dependencies": [
        4,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Analytics and Error Tracking",
      "description": "Add analytics for user behavior tracking and error monitoring.",
      "details": "Integrate Google Analytics 4 for user behavior tracking. Implement custom event tracking for key user actions. Set up error tracking using Sentry or LogRocket. Create a custom _error.js page for better error handling. Ensure GDPR compliance with cookie consent for analytics.",
      "testStrategy": "Verify correct tracking of page views and custom events. Test error reporting by intentionally triggering errors. Ensure analytics respects user's cookie preferences.",
      "priority": "low",
      "dependencies": [
        4,
        9
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement A/B Testing Infrastructure",
      "description": "Set up infrastructure for A/B testing different UI variations.",
      "details": "Integrate an A/B testing library like Google Optimize or LaunchDarkly. Create a system for defining and managing feature flags. Implement A/B test for two variations of the main CTA on the home page. Set up tracking to measure the performance of each variation.",
      "testStrategy": "Write tests to ensure correct rendering of different variations. Verify that A/B test results are correctly tracked in analytics. Test the system's ability to gradually roll out new features.",
      "priority": "low",
      "dependencies": [
        10,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement PostgreSQL Database Integration for User Management",
      "description": "Integrate the existing user registration system with PostgreSQL database to store and manage user information, including email verification and authentication processes.",
      "details": "1. Set up PostgreSQL connection and environment variables:\n   - Install required packages: `npm install pg` or `npm install @prisma/client`\n   - Create a `.env` file to store database credentials securely\n   - Set up environment variables for DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD\n\n2. Implement database connection module:\n   - Create a `db.ts` file in the `src/lib` directory\n   - If using `pg`:\n     ```typescript\n     import { Pool } from 'pg';\n     \n     const pool = new Pool({\n       host: process.env.DB_HOST,\n       port: parseInt(process.env.DB_PORT || '5432'),\n       database: process.env.DB_NAME,\n       user: process.env.DB_USER,\n       password: process.env.DB_PASSWORD,\n     });\n     \n     export default pool;\n     ```\n   - If using Prisma:\n     - Set up Prisma schema in `prisma/schema.prisma`\n     - Run `npx prisma generate` to generate Prisma client\n     - Create a `prisma.ts` file:\n       ```typescript\n       import { PrismaClient } from '@prisma/client';\n       \n       const prisma = new PrismaClient();\n       \n       export default prisma;\n       ```\n\n3. Modify the existing sign-up API to use PostgreSQL:\n   - Update the API route in `pages/api/auth/signup.ts`\n   - Replace in-memory storage with database queries\n   - Example using `pg`:\n     ```typescript\n     import pool from '@/lib/db';\n     \n     // ... existing imports and setup\n     \n     export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n       if (req.method === 'POST') {\n         const { email, password, name } = req.body;\n         \n         try {\n           const hashedPassword = await bcrypt.hash(password, 10);\n           const result = await pool.query(\n             'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id',\n             [email, hashedPassword, name]\n           );\n           \n           // ... rest of the sign-up logic\n         } catch (error) {\n           console.error('Error during sign-up:', error);\n           res.status(500).json({ message: 'Internal server error' });\n         }\n       } else {\n         res.setHeader('Allow', ['POST']);\n         res.status(405).end(`Method ${req.method} Not Allowed`);\n       }\n     }\n     ```\n\n4. Update email verification system to use database:\n   - Modify the email verification token generation and storage\n   - Update the verification process to check against the database\n   - Example:\n     ```typescript\n     // Generate and store token\n     const verificationToken = generateToken();\n     await pool.query(\n       'UPDATE users SET email_verification_token = $1, email_verification_expires = $2 WHERE id = $3',\n       [verificationToken, new Date(Date.now() + 24 * 60 * 60 * 1000), userId]\n     );\n     \n     // Verify token\n     const result = await pool.query(\n       'SELECT * FROM users WHERE email_verification_token = $1 AND email_verification_expires > $2',\n       [token, new Date()]\n     );\n     if (result.rows.length > 0) {\n       await pool.query(\n         'UPDATE users SET email_verified = true, email_verification_token = NULL, email_verification_expires = NULL WHERE id = $1',\n         [result.rows[0].id]\n       );\n       // ... handle successful verification\n     }\n     ```\n\n5. Implement user authentication and session management:\n   - Create login API endpoint using database queries\n   - Implement JWT token generation and validation\n   - Store session information in the database if needed\n\n6. Extend user model for social login preparation:\n   - Add provider and provider_id fields to the users table\n   - Update sign-up and login logic to handle different providers\n\n7. Implement error handling and input validation:\n   - Use try-catch blocks for database operations\n   - Implement proper input sanitization to prevent SQL injection\n   - Handle unique constraint violations (e.g., duplicate email addresses)\n\n8. Optimize database queries:\n   - Create appropriate indexes on frequently queried columns\n   - Use prepared statements for better performance and security\n\n9. Implement database migration strategy:\n   - If using Prisma, utilize its migration features\n   - If using raw SQL, create migration scripts for schema changes\n\n10. Update all affected API routes and services to use the new database integration",
      "testStrategy": "1. Unit Tests:\n   - Write unit tests for database connection module\n   - Test individual database operations (insert, select, update, delete)\n\n2. Integration Tests:\n   - Test the sign-up process end-to-end\n   - Verify email verification flow with database integration\n   - Test login functionality and session management\n   - Ensure social login fields are correctly handled\n\n3. API Tests:\n   - Use tools like Jest and Supertest to test API endpoints\n   - Verify correct HTTP status codes and response formats\n   - Test error handling for invalid inputs and database errors\n\n4. Database Integrity Tests:\n   - Verify data consistency after various operations\n   - Test unique constraints and foreign key relationships\n\n5. Performance Tests:\n   - Measure query execution times\n   - Test database connection pooling under load\n\n6. Security Tests:\n   - Attempt SQL injection attacks to ensure proper protection\n   - Verify that sensitive data (like password hashes) is not exposed\n\n7. Migration Tests:\n   - Test database migration scripts\n   - Verify data integrity after migrations\n\n8. Manual Testing:\n   - Perform manual sign-up, login, and email verification\n   - Verify correct storage and retrieval of user data\n\n9. Environment Variable Tests:\n   - Test application behavior with different database configurations\n\n10. Error Handling Tests:\n    - Simulate database connection failures\n    - Test application behavior with invalid credentials\n\n11. Cleanup and Rollback Tests:\n    - Ensure test data is properly cleaned up after each test\n    - Verify rollback functionality for failed operations\n\n12. Logging and Monitoring:\n    - Verify that database operations are properly logged\n    - Test any implemented monitoring or alerting systems",
      "status": "done",
      "dependencies": [
        6
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up PostgreSQL connection and environment variables",
          "description": "Install required packages, create a .env file, and set up environment variables for database credentials.",
          "dependencies": [],
          "details": "Install pg or @prisma/client package. Create .env file with DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD variables. Ensure .env is in .gitignore.",
          "status": "done",
          "testStrategy": "Verify .env file exists with correct variables. Test database connection using a simple query."
        },
        {
          "id": 2,
          "title": "Implement database connection module",
          "description": "Create a database connection module to handle PostgreSQL connections.",
          "dependencies": [
            1
          ],
          "details": "Create db.ts or prisma.ts in src/lib. Implement connection logic using environment variables. Export connection object for use in other modules.",
          "status": "done",
          "testStrategy": "Write unit tests to ensure connection object is created correctly and can execute a simple query."
        },
        {
          "id": 3,
          "title": "Modify sign-up API to use PostgreSQL",
          "description": "Update the existing sign-up API to store user information in PostgreSQL instead of in-memory storage.",
          "dependencies": [
            2
          ],
          "details": "Modify pages/api/auth/signup.ts. Replace in-memory storage with database queries. Handle password hashing and user insertion. Implement error handling for database operations.\n<info added on 2025-05-26T05:33:37.052Z>\n✅ PostgreSQL integration completed with all tests successful!\n\n**Implemented Features:**\n1. Sign-up API with PostgreSQL integration\n   - Email duplication check\n   - Password hashing (bcrypt)\n   - User data storage\n   - Email verification token generation and storage\n\n2. Email verification API with PostgreSQL integration\n   - Token validation and email verification processing\n   - User status updates\n\n3. Login API with PostgreSQL integration\n   - User lookup and password verification\n   - JWT token generation\n   - Email verification status check\n\n**Database Schema Modifications:**\n- Changed email_verification_token column from VARCHAR(255) to TEXT to accommodate JWT token length\n\n**Test Results:**\n- All database integration features working properly\n- User creation, lookup, and update functions verified\n- Password hashing and verification working correctly\n- JWT token generation and storage functioning as expected\n\n**Modified Files:**\n- back/src/routes/auth.js: Fully converted to PostgreSQL queries\n- back/src/lib/db.js: Implemented user-related query functions\n- .env: Added JWT_SECRET\n\nNote: Email service has some issues, but the core PostgreSQL integration works perfectly.\n</info added on 2025-05-26T05:33:37.052Z>",
          "status": "done",
          "testStrategy": "Create integration tests for sign-up API. Verify user data is correctly stored in the database."
        },
        {
          "id": 4,
          "title": "Update email verification system",
          "description": "Modify the email verification process to use the PostgreSQL database for token storage and verification.",
          "dependencies": [
            3
          ],
          "details": "Update token generation and storage to use database queries. Modify verification process to check against database records. Implement token expiration logic.",
          "status": "done",
          "testStrategy": "Write unit tests for token generation and verification. Create integration tests for the entire email verification flow."
        },
        {
          "id": 5,
          "title": "Implement user authentication with database integration",
          "description": "Create login API endpoint using database queries and implement JWT token generation and validation.",
          "dependencies": [
            3
          ],
          "details": "Develop login API in pages/api/auth/login.ts. Use database queries to validate user credentials. Implement JWT token generation for authenticated users. Store session information in the database if required.",
          "status": "done",
          "testStrategy": "Create unit tests for JWT token generation and validation. Develop integration tests for the login process, including database interaction and token issuance."
        }
      ]
    }
  ]
}