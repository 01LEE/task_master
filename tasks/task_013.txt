# Task ID: 13
# Title: Implement PostgreSQL Database Integration for User Management
# Status: done
# Dependencies: 6
# Priority: high
# Description: Integrate the existing user registration system with PostgreSQL database to store and manage user information, including email verification and authentication processes.
# Details:
1. Set up PostgreSQL connection and environment variables:
   - Install required packages: `npm install pg` or `npm install @prisma/client`
   - Create a `.env` file to store database credentials securely
   - Set up environment variables for DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD

2. Implement database connection module:
   - Create a `db.ts` file in the `src/lib` directory
   - If using `pg`:
     ```typescript
     import { Pool } from 'pg';
     
     const pool = new Pool({
       host: process.env.DB_HOST,
       port: parseInt(process.env.DB_PORT || '5432'),
       database: process.env.DB_NAME,
       user: process.env.DB_USER,
       password: process.env.DB_PASSWORD,
     });
     
     export default pool;
     ```
   - If using Prisma:
     - Set up Prisma schema in `prisma/schema.prisma`
     - Run `npx prisma generate` to generate Prisma client
     - Create a `prisma.ts` file:
       ```typescript
       import { PrismaClient } from '@prisma/client';
       
       const prisma = new PrismaClient();
       
       export default prisma;
       ```

3. Modify the existing sign-up API to use PostgreSQL:
   - Update the API route in `pages/api/auth/signup.ts`
   - Replace in-memory storage with database queries
   - Example using `pg`:
     ```typescript
     import pool from '@/lib/db';
     
     // ... existing imports and setup
     
     export default async function handler(req: NextApiRequest, res: NextApiResponse) {
       if (req.method === 'POST') {
         const { email, password, name } = req.body;
         
         try {
           const hashedPassword = await bcrypt.hash(password, 10);
           const result = await pool.query(
             'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id',
             [email, hashedPassword, name]
           );
           
           // ... rest of the sign-up logic
         } catch (error) {
           console.error('Error during sign-up:', error);
           res.status(500).json({ message: 'Internal server error' });
         }
       } else {
         res.setHeader('Allow', ['POST']);
         res.status(405).end(`Method ${req.method} Not Allowed`);
       }
     }
     ```

4. Update email verification system to use database:
   - Modify the email verification token generation and storage
   - Update the verification process to check against the database
   - Example:
     ```typescript
     // Generate and store token
     const verificationToken = generateToken();
     await pool.query(
       'UPDATE users SET email_verification_token = $1, email_verification_expires = $2 WHERE id = $3',
       [verificationToken, new Date(Date.now() + 24 * 60 * 60 * 1000), userId]
     );
     
     // Verify token
     const result = await pool.query(
       'SELECT * FROM users WHERE email_verification_token = $1 AND email_verification_expires > $2',
       [token, new Date()]
     );
     if (result.rows.length > 0) {
       await pool.query(
         'UPDATE users SET email_verified = true, email_verification_token = NULL, email_verification_expires = NULL WHERE id = $1',
         [result.rows[0].id]
       );
       // ... handle successful verification
     }
     ```

5. Implement user authentication and session management:
   - Create login API endpoint using database queries
   - Implement JWT token generation and validation
   - Store session information in the database if needed

6. Extend user model for social login preparation:
   - Add provider and provider_id fields to the users table
   - Update sign-up and login logic to handle different providers

7. Implement error handling and input validation:
   - Use try-catch blocks for database operations
   - Implement proper input sanitization to prevent SQL injection
   - Handle unique constraint violations (e.g., duplicate email addresses)

8. Optimize database queries:
   - Create appropriate indexes on frequently queried columns
   - Use prepared statements for better performance and security

9. Implement database migration strategy:
   - If using Prisma, utilize its migration features
   - If using raw SQL, create migration scripts for schema changes

10. Update all affected API routes and services to use the new database integration

# Test Strategy:
1. Unit Tests:
   - Write unit tests for database connection module
   - Test individual database operations (insert, select, update, delete)

2. Integration Tests:
   - Test the sign-up process end-to-end
   - Verify email verification flow with database integration
   - Test login functionality and session management
   - Ensure social login fields are correctly handled

3. API Tests:
   - Use tools like Jest and Supertest to test API endpoints
   - Verify correct HTTP status codes and response formats
   - Test error handling for invalid inputs and database errors

4. Database Integrity Tests:
   - Verify data consistency after various operations
   - Test unique constraints and foreign key relationships

5. Performance Tests:
   - Measure query execution times
   - Test database connection pooling under load

6. Security Tests:
   - Attempt SQL injection attacks to ensure proper protection
   - Verify that sensitive data (like password hashes) is not exposed

7. Migration Tests:
   - Test database migration scripts
   - Verify data integrity after migrations

8. Manual Testing:
   - Perform manual sign-up, login, and email verification
   - Verify correct storage and retrieval of user data

9. Environment Variable Tests:
   - Test application behavior with different database configurations

10. Error Handling Tests:
    - Simulate database connection failures
    - Test application behavior with invalid credentials

11. Cleanup and Rollback Tests:
    - Ensure test data is properly cleaned up after each test
    - Verify rollback functionality for failed operations

12. Logging and Monitoring:
    - Verify that database operations are properly logged
    - Test any implemented monitoring or alerting systems

# Subtasks:
## 1. Set up PostgreSQL connection and environment variables [done]
### Dependencies: None
### Description: Install required packages, create a .env file, and set up environment variables for database credentials.
### Details:
Install pg or @prisma/client package. Create .env file with DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD variables. Ensure .env is in .gitignore.

## 2. Implement database connection module [done]
### Dependencies: 13.1
### Description: Create a database connection module to handle PostgreSQL connections.
### Details:
Create db.ts or prisma.ts in src/lib. Implement connection logic using environment variables. Export connection object for use in other modules.

## 3. Modify sign-up API to use PostgreSQL [done]
### Dependencies: 13.2
### Description: Update the existing sign-up API to store user information in PostgreSQL instead of in-memory storage.
### Details:
Modify pages/api/auth/signup.ts. Replace in-memory storage with database queries. Handle password hashing and user insertion. Implement error handling for database operations.
<info added on 2025-05-26T05:33:37.052Z>
âœ… PostgreSQL integration completed with all tests successful!

**Implemented Features:**
1. Sign-up API with PostgreSQL integration
   - Email duplication check
   - Password hashing (bcrypt)
   - User data storage
   - Email verification token generation and storage

2. Email verification API with PostgreSQL integration
   - Token validation and email verification processing
   - User status updates

3. Login API with PostgreSQL integration
   - User lookup and password verification
   - JWT token generation
   - Email verification status check

**Database Schema Modifications:**
- Changed email_verification_token column from VARCHAR(255) to TEXT to accommodate JWT token length

**Test Results:**
- All database integration features working properly
- User creation, lookup, and update functions verified
- Password hashing and verification working correctly
- JWT token generation and storage functioning as expected

**Modified Files:**
- back/src/routes/auth.js: Fully converted to PostgreSQL queries
- back/src/lib/db.js: Implemented user-related query functions
- .env: Added JWT_SECRET

Note: Email service has some issues, but the core PostgreSQL integration works perfectly.
</info added on 2025-05-26T05:33:37.052Z>

## 4. Update email verification system [done]
### Dependencies: 13.3
### Description: Modify the email verification process to use the PostgreSQL database for token storage and verification.
### Details:
Update token generation and storage to use database queries. Modify verification process to check against database records. Implement token expiration logic.

## 5. Implement user authentication with database integration [done]
### Dependencies: 13.3
### Description: Create login API endpoint using database queries and implement JWT token generation and validation.
### Details:
Develop login API in pages/api/auth/login.ts. Use database queries to validate user credentials. Implement JWT token generation for authenticated users. Store session information in the database if required.

